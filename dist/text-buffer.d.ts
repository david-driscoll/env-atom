// Generated by typings
// Source: ../event-kit/Disposable.d.ts
declare module 'event-kit/Disposable' {
class Disposable {
  static isDisposable(object: Object): boolean;
  constructor(disposalAction: Function);
  dispose(): void;
}

export = Disposable;
}
declare module 'event-kit/Disposable' {
import alias = require('event-kit/Disposable');
export = alias;
}

// Generated by typings
// Source: point.d.ts
declare module '~text-buffer/point' {
class Point {
  static fromObject(object: Point | number[], copy?: boolean): Point;
  static min(point1: Point, point2: Point): Point;
  row: number;
  column: number;
  constructor(row: number, column: number);
  copy(): Point;
  negate(): Point;

  compare(other: Point): Point;
  isEqual(other: Point): boolean;
  isLessThan(other: Point): boolean;
  isLessThanOrEqual(other: Point): boolean;
  isGreaterThan(other: Point): boolean;
  isGreaterThanOrEqual(other: Point): boolean;
  freeze(): void;
  translate(other: Point): Point;
  traverse(other: Point): Point;
  toArray(): number[];
  serialize(): number[];
  toString(): string;
}

export = Point;
}
declare module 'text-buffer/point' {
import alias = require('~text-buffer/point');
export = alias;
}

// Generated by typings
// Source: range.d.ts
declare module '~text-buffer/range' {
import Point = require('~text-buffer/point');

class Range {
  start: Point;
  end: Point;
  static fromObject(object: Range | Point[], copy?: boolean): Range;
  constructor(pointA: Point, pointB: Point);
  copy(): Range;
  negate(): Range;

  static deserialize(array: any): Range;
  serialize(): any;

  isEmpty(): boolean;
  isSingleLine(): boolean;
  getRowCount(): number;
  getRows(): number[];

  freeze(): void;
  union(otherRange: Range): Range;
  translate(startDelta: Point, endDelta?: Point): Range;
  traverse(delta: Point): Range;


  compare(otherRange: Range): Range;
  isEqual(otherRange: Range): boolean;
  coversSameRows(otherRange: Range): boolean;
  intersectsWith(otherRange: Range, exclusive?: boolean): boolean;
  containsRange(otherRange: Range, exclusive?: boolean): boolean;
  containsPoint(point: Point, exclusive?: boolean): boolean;
  intersectsRow(row: number): boolean;
  intersectsRowRange(startRow: number, endRow: number): boolean;
  toString(): string;

}

export = Range;
}
declare module 'text-buffer/range' {
import alias = require('~text-buffer/range');
export = alias;
}

// Generated by typings
// Source: ../event-kit/disposable.d.ts
declare module 'event-kit/disposable' {
class Disposable {
  static isDisposable(object: Object): boolean;
  constructor(disposalAction: Function);
  dispose(): void;
}

export = Disposable;
}
declare module 'event-kit/disposable' {
import alias = require('event-kit/disposable');
export = alias;
}

// Generated by typings
// Source: marker.d.ts
declare module '~text-buffer/marker' {

import Point = require('~text-buffer/point');
import Range = require('~text-buffer/range');
import Disposable = require('event-kit/disposable')

class Marker {
  constructor(id, layer, range: Range, params: Object);
  onDidDestroy: (callback: () => void) => Disposable;
  onDidChange(callback: (event: {
    oldHeadBufferPosition: Point;
    newHeadBufferPosition: Point;
    oldTailBufferPosition: Point;
    newTailBufferPosition: Point;
    oldHeadScreenPosition: Point;
    newHeadScreenPosition: Point;
    oldTailScreenPosition: Point;
    newTailScreenPosition: Point;
    wasValid: boolean;
    isValid: boolean;
    hadTail: boolean;
    hasTail: boolean;
    oldProperties: Object;
    newProperties: Object;
    textChanged: boolean;
  }) => void): Disposable;
  getRange(): Range;
  setRange(range: Range, params?: { reversed?: boolean, exclusive?: boolean }): void;
  getHeadPosition(): Position;
  setHeadPosition(position: Position): void;
  getTailPosition(): Position;
  setTailPosition(position: Position): void;
  getStartPosition(): Position;
  getEndPosition(): Position;
  clearTail(): void;
  plantTail(): void;
  isReversed(): boolean;
  hasTail(): boolean;
  isValid(): boolean;
  isDestroyed(): boolean;
  isExclusive(): boolean;
  isEqual(other: Marker): boolean;
  getInvalidationStrategy(): string;
  getProperties(): Object;
  setProperties(properties: Object): void;
  copy(option?: Object): Marker;
  destroy(): void;
  compare(other: Marker): boolean;
}

export = Marker;
}
declare module 'text-buffer/marker' {
import alias = require('~text-buffer/marker');
export = alias;
}

// Generated by typings
// Source: ../event-kit/event-handler.d.ts
declare module 'event-kit/event-handler' {
import Disposable = require('event-kit/disposable');

interface EventHandler {
  (callback: () => void): Disposable;
}

export = EventHandler;
}
declare module 'event-kit/event-handler' {
import alias = require('event-kit/event-handler');
export = alias;
}

// Generated by typings
// Source: marker-layer.d.ts
declare module '~text-buffer/marker-layer' {
import Marker = require('~text-buffer/marker');
import Point = require('~text-buffer/point');
import Disposable = require('event-kit/disposable');
import EventHandler = require('event-kit/event-handler');

class MarkerLayer {
  // Lifecycle
  copy(): void;
  destroy(): void;
  isDestroyed(): boolean;
  // Querying
  getMarker(): Marker;
  getMarkers(): Marker[];
  getMarkerCount(): number;
  /**
   * @params params A hash of key-value pairs constraining the set of returned markers.
   * You can query against custom marker properties by listing the desired key-value pairs here.
   * In addition, the following keys are reserved and have special semantics:
   *    startPosition	Only include markers that start at the given Point.
   *    endPosition Only include markers that end at the given Point.
   *    containsPoint Only include markers that contain the given Point, inclusive.
   *    containsRange	Only include markers that contain the given Range, inclusive.
   *    startRow Only include markers that start at the given row Number.
   *    endRow Only include markers that end at the given row Number.
   *    intersectsRow Only include markers that intersect the given row Number.
   */
  findMarkers(params: {
    startPosition?: Point,
    endPosition?: Point,
    containsPoint?: Point,
    containsRange?: Range,
    startRow?: number,
    endRow?: number;
    intersectsRow?: number
  }): Marker[];
  // Marker creation
  markRange(range: Range | Point[], properties: {
    reversed?: boolean,
    persistent?: boolean,
    invalidate?: 'never' | 'surround' | 'overlap' | 'inside' | 'touch'
  }): Marker;
  markPosition(position: Point | number[], properties: {
    reversed?: boolean,
    persistent?: boolean,
    invalidate?: 'never' | 'surround' | 'overlap' | 'inside' | 'touch'
  }): Marker;
  // Event subscription

  onDidUpdate: EventHandler;
  onDidCreateMarker: EventHandler;
  onDidDestroy(): Disposable;
}

export = MarkerLayer;
}
declare module 'text-buffer/marker-layer' {
import alias = require('~text-buffer/marker-layer');
export = alias;
}

// Generated by typings
// Source: scan-function.d.ts
declare module '~text-buffer/scan-function' {

interface ScanFunction {
  (regex: RegExp, iterator: (match: any, matchText: string, range: Range, stop: Function, replace: (value: string) => void) => void): void;
}

export = ScanFunction;
}
declare module 'text-buffer/scan-function' {
import alias = require('~text-buffer/scan-function');
export = alias;
}

// Generated by typings
// Source: scan-in-range-function.d.ts
declare module '~text-buffer/scan-in-range-function' {

interface ScanInRangeFunction {
  (regex: RegExp, range: Range, iterator: (match: any, matchText: string, range: Range, stop: Function, replace: (value: string) => void) => void): void;
}

export = ScanInRangeFunction;
}
declare module 'text-buffer/scan-in-range-function' {
import alias = require('~text-buffer/scan-in-range-function');
export = alias;
}

// Generated by typings
// Source: text-buffer.d.ts
declare module '~text-buffer/text-buffer' {
import Disposable = require('event-kit/Disposable');

import Point = require('~text-buffer/point');
import Range = require('~text-buffer/range');
import Marker = require('~text-buffer/marker');
import MarkerLayer = require('~text-buffer/marker-layer');
import ScanFunction = require('~text-buffer/scan-function');
import ScanInRangeFunction = require('~text-buffer/scan-in-range-function');


namespace TextBuffer {
  export var Point: Point;
  export var Range: Range;
}

class TextBuffer {
  constructor(params: string | { load: boolean, text: string });
  onWillChange(callback: (event: {
    oldRange: Range,
    newRange: Range,
    oldText: string,
    newText: string
  }) => void): Disposable;
  onDidChange(callback: (event: {
    oldRange: Range,
    newRange: Range,
    oldText: string,
    newText: string
  }) => void): Disposable;
  onDidStopChanging: (callback: () => void) => Disposable;
  onDidConflict: (callback: () => void) => Disposable;
  onDidChangeModified(callback: (modified: boolean) => void): Disposable;
  onDidUpdateMarkers: (callback: () => void) => Disposable;
  onDidCreateMarker(callback: (marker: Marker) => void): Disposable;
  onDidChangePath(callback: (path: string) => void): Disposable;
  onDidChangeEncoding(callback: (encoding: string) => void): Disposable;
  onWillSave: (callback: () => void) => Disposable;
  onDidSave(callback: (event: { path: string }) => void): Disposable;
  onDidDelete: (callback: () => void) => Disposable;
  onWillReload: (callback: () => void) => Disposable;
  onDidReload: (callback: () => void) => Disposable;
  onDidDestroy: (callback: () => void) => Disposable;
  onWillThrowWatchError(callback: (errorObject: {
    error: Object,
    handle(): void
  }) => void): Disposable;
  getStoppedChangingDelay(): number;
  isModified(): boolean;
  isInConflict(): boolean;
  getPath(): string;
  setPath(filePath: string): void;
  setEncoding(encoding: string): void;
  getEncoding(): string;
  getUri(): string;
  isEmpty(): boolean;
  getText(): string;
  getTextInRange(range: Range): string;
  getLines(): string[];
  getLastLine(): string;
  lineForRow(row: number): string;
  lineEndingForRow(row: number): '\n' | '\r' | '\r\n' | '';
  lineLengthForRow(row: number): number;
  isRowBlank(row: number): boolean;
  previousNonBlankRow(startRow: number): number;
  nextNonBlankRow(startRow: number): number;
  setText(text: string): Range;
  setTextViaDiff(text: string): any;
  setTextInRange(range: Range, text: string, options?: { normalizeLineEndings?: boolean, undo?: 'skip' }): Range;
  insert(position: Point, text: string, options?: { normalizeLineEndings?: boolean, undo?: 'skip' }): Range;
  append(text: string, options?: { normalizeLineEndings?: boolean, undo?: 'skip' }): Range;
  delete(range: Range): Range;
  deleteRow(row: number): Range;
  deleteRows(startRow: number, endRow: number): Range;
  addMarkerLayer(options: { maintainHistory: boolean }): MarkerLayer;
  getMarkerLayer(id: any): MarkerLayer;
  markRange(range: Range | Point[], properties: {
    reversed?: boolean,
    persistent?: boolean,
    invalidate?: 'never' | 'surround' | 'overlap' | 'inside' | 'touch'
  }): Marker;
  markPosition(position: Point | number[], properties: {
    reversed?: boolean,
    persistent?: boolean,
    invalidate?: 'never' | 'surround' | 'overlap' | 'inside' | 'touch'
  }): Marker;
  getMarkers(): Marker[];
  getMarker(id: number): Marker;
  /**
   * @params params A hash of key-value pairs constraining the set of returned markers.
   * You can query against custom marker properties by listing the desired key-value pairs here.
   * In addition, the following keys are reserved and have special semantics:
   *    startPosition	Only include markers that start at the given Point.
   *    endPosition Only include markers that end at the given Point.
   *    containsPoint Only include markers that contain the given Point, inclusive.
   *    containsRange	Only include markers that contain the given Range, inclusive.
   *    startRow Only include markers that start at the given row Number.
   *    endRow Only include markers that end at the given row Number.
   *    intersectsRow Only include markers that intersect the given row Number.
   */
  findMarkers(params: {
    startPosition?: Point,
    endPosition?: Point,
    containsPoint?: Point,
    containsRange?: Range,
    startRow?: number,
    endRow?: number;
    intersectsRow?: number
  }): Marker[];
  getMarkerCount(): number;
  undo(): void;
  redo(): void;
  transact(fn: () => void): void;
  transact(groupingInterval: number, fn: () => void): void;
  clearUndoStack(): void;
  createCheckpoint(): any;
  revertToCheckpoint(): boolean;
  groupChangesSinceCheckpoint(): boolean;
  scan: ScanFunction;
  backwardsScan: ScanFunction;
  scanInRange: ScanInRangeFunction;
  backwardsScanInRange: ScanInRangeFunction;
  replace(regex: RegExp, replacementText: string): number;
  getRange(): Range;
  getLineCount(): number;
  getLastRow(): number;

  getFirstPosition(): Point;
  getEndPosition(): Point;
  getMaxCharacterIndex(): number;
  rangeForRow(row: number, includeNewline: boolean): Range;
  characterIndexForPosition(position: Point): number;
  positionForCharacterIndex(offset: number): Point;
  clipRange(range: Range): Range;
  clipPosition(position: Point): Point;
  save(): void;
  saveAs(filePath: string): void;
  reload(): void;
}

export = TextBuffer;
}
declare module 'text-buffer/text-buffer' {
import alias = require('~text-buffer/text-buffer');
export = alias;
}
declare module 'text-buffer' {
import alias = require('~text-buffer/text-buffer');
export = alias;
}
