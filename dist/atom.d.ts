// Generated by typings
// Source: buffer-process.d.ts
declare module '~atom/buffer-process' {
import Disposable = require('event-kit/disposable');

class BufferedProcess {
  constructor(options: {
    command: string,
    args?: any[],
    options?: Object,
    stdout?: (data: string) => void;
    stderr?: (data: string) => void;
    exit?: (code: number) => void;
  });
  onWillThrowError(callback: (errorObject: { error: Object, handle(): void }) => void): Disposable;
  kill(): void;
}


export = BufferedProcess;
}
declare module 'atom/buffer-process' {
import alias = require('~atom/buffer-process');
export = alias;
}

// Generated by typings
// Source: buffer-node-process.d.ts
declare module '~atom/buffer-node-process' {
import BufferedProcess = require('~atom/buffer-process');
class BufferedNodeProcess extends BufferedProcess {
}

export = BufferedNodeProcess;
}
declare module 'atom/buffer-node-process' {
import alias = require('~atom/buffer-node-process');
export = alias;
}

// Generated by typings
// Source: git-repository.d.ts
declare module '~atom/git-repository' {
import Disposable = require('event-kit/disposable');

class GitRepository {
  static open(path: string, options?: { refreshOnWindowFocus: boolean }): GitRepository;
  destroy();
  onDidDestroy: (callback: () => void) => Disposable;
  onDidChangeStatus(callback: (event: {
    path: string;
    pathStatus: number;
  }) => void): Disposable;
  onDidChangeStatuses: (callback: () => void) => Disposable;
  getType(): string;
  getPath(): string;
  getWorkingDirectory(): string;
  isProjectAtRoot(): boolean;
  relativize(): string;
  hasBranch(): boolean;
  getShortHead(path: string): string;
  isSubmodule(path: string): boolean;
  getAheadBehindCount(reference: string, path?: string): number;
  getCachedUpstreamAheadBehindCount(path: string): { ahead: number, behind: number };
  getConfigValue(path: string): any;
  getOriginURL(path?: string): string;
  getUpstreamBranch(path: string): string;
  getReferences(path: string): { heads: string[], remotes: string[], tags: string[] };
  getReferenceTarget(reference: string, path?: string): string;
  isPathModified(path: string): boolean;
  isPathNew(path: string): boolean;
  isPathIgnored(path): boolean;
  getDirectoryStatus(path: string): number;
  getPathStatus(): number;
  getCachedPathStatus(path: string): number;
  isStatusModified(status: boolean): boolean;
  isStatusNew(status: number): boolean;
  getDiffStats(path: string): { added: number, deleted: number };
  getLinkDiffs(path: string, text: string): { oldStart: number, newStart: number, oldLines: number, newLines: number }[];
  checkoutHead(path: string): boolean;
  checkoutReference(reference: string, create: boolean): boolean;
}


export = GitRepository;
}
declare module 'atom/git-repository' {
import alias = require('~atom/git-repository');
export = alias;
}

// Generated by typings
// Source: notification.d.ts
declare module '~atom/notification' {
import Disposable = require('event-kit/disposable');

class Notification {
  onDidDismiss: (callback: () => void) => Disposable;
  onDidDisplay: (callback: () => void) => Disposable;
  getType(): string;
  getMessage(): string;

  // Extended Methods
  dismiss(): void;
}

export = Notification;
}
declare module 'atom/notification' {
import alias = require('~atom/notification');
export = alias;
}

// Generated by typings
// Source: ../event-kit/Disposable.d.ts
declare module 'event-kit/Disposable' {
class Disposable {
  static isDisposable(object: Object): boolean;
  constructor(disposalAction: Function);
  dispose(): void;
}

export = Disposable;
}
declare module 'event-kit/Disposable' {
import alias = require('event-kit/Disposable');
export = alias;
}

// Generated by typings
// Source: ../text-buffer/marker.d.ts
declare module 'text-buffer/marker' {

import Point = require('text-buffer/point');
import Range = require('text-buffer/range');
import Disposable = require('event-kit/disposable')

class Marker {
  constructor(id, layer, range: Range, params: Object);
  onDidDestroy: (callback: () => void) => Disposable;
  onDidChange(callback: (event: {
    oldHeadBufferPosition: Point;
    newHeadBufferPosition: Point;
    oldTailBufferPosition: Point;
    newTailBufferPosition: Point;
    oldHeadScreenPosition: Point;
    newHeadScreenPosition: Point;
    oldTailScreenPosition: Point;
    newTailScreenPosition: Point;
    wasValid: boolean;
    isValid: boolean;
    hadTail: boolean;
    hasTail: boolean;
    oldProperties: Object;
    newProperties: Object;
    textChanged: boolean;
  }) => void): Disposable;
  getRange(): Range;
  setRange(range: Range, params?: { reversed?: boolean, exclusive?: boolean }): void;
  getHeadPosition(): Position;
  setHeadPosition(position: Position): void;
  getTailPosition(): Position;
  setTailPosition(position: Position): void;
  getStartPosition(): Position;
  getEndPosition(): Position;
  clearTail(): void;
  plantTail(): void;
  isReversed(): boolean;
  hasTail(): boolean;
  isValid(): boolean;
  isDestroyed(): boolean;
  isExclusive(): boolean;
  isEqual(other: Marker): boolean;
  getInvalidationStrategy(): string;
  getProperties(): Object;
  setProperties(properties: Object): void;
  copy(option?: Object): Marker;
  destroy(): void;
  compare(other: Marker): boolean;
}

export = Marker;
}
declare module 'text-buffer/marker' {
import alias = require('text-buffer/marker');
export = alias;
}

// Generated by typings
// Source: ../text-buffer/marker-layer.d.ts
declare module 'text-buffer/marker-layer' {
import Marker = require('text-buffer/marker');
import Point = require('text-buffer/point');
import Disposable = require('event-kit/disposable');
import EventHandler = require('event-kit/event-handler');

class MarkerLayer {
  // Lifecycle
  copy(): void;
  destroy(): void;
  isDestroyed(): boolean;
  // Querying
  getMarker(): Marker;
  getMarkers(): Marker[];
  getMarkerCount(): number;
  /**
   * @params params A hash of key-value pairs constraining the set of returned markers.
   * You can query against custom marker properties by listing the desired key-value pairs here.
   * In addition, the following keys are reserved and have special semantics:
   *    startPosition	Only include markers that start at the given Point.
   *    endPosition Only include markers that end at the given Point.
   *    containsPoint Only include markers that contain the given Point, inclusive.
   *    containsRange	Only include markers that contain the given Range, inclusive.
   *    startRow Only include markers that start at the given row Number.
   *    endRow Only include markers that end at the given row Number.
   *    intersectsRow Only include markers that intersect the given row Number.
   */
  findMarkers(params: {
    startPosition?: Point,
    endPosition?: Point,
    containsPoint?: Point,
    containsRange?: Range,
    startRow?: number,
    endRow?: number;
    intersectsRow?: number
  }): Marker[];
  // Marker creation
  markRange(range: Range | Point[], properties: {
    reversed?: boolean,
    persistent?: boolean,
    invalidate?: 'never' | 'surround' | 'overlap' | 'inside' | 'touch'
  }): Marker;
  markPosition(position: Point | number[], properties: {
    reversed?: boolean,
    persistent?: boolean,
    invalidate?: 'never' | 'surround' | 'overlap' | 'inside' | 'touch'
  }): Marker;
  // Event subscription

  onDidUpdate: EventHandler;
  onDidCreateMarker: EventHandler;
  onDidDestroy(): Disposable;
}

export = MarkerLayer;
}
declare module 'text-buffer/marker-layer' {
import alias = require('text-buffer/marker-layer');
export = alias;
}

// Generated by typings
// Source: ../text-buffer/scan-function.d.ts
declare module 'text-buffer/scan-function' {

interface ScanFunction {
  (regex: RegExp, iterator: (match: any, matchText: string, range: Range, stop: Function, replace: (value: string) => void) => void): void;
}

export = ScanFunction;
}
declare module 'text-buffer/scan-function' {
import alias = require('text-buffer/scan-function');
export = alias;
}

// Generated by typings
// Source: ../text-buffer/scan-in-range-function.d.ts
declare module 'text-buffer/scan-in-range-function' {

interface ScanInRangeFunction {
  (regex: RegExp, range: Range, iterator: (match: any, matchText: string, range: Range, stop: Function, replace: (value: string) => void) => void): void;
}

export = ScanInRangeFunction;
}
declare module 'text-buffer/scan-in-range-function' {
import alias = require('text-buffer/scan-in-range-function');
export = alias;
}

// Generated by typings
// Source: ../text-buffer/text-buffer.d.ts
declare module 'text-buffer/text-buffer' {
import Disposable = require('event-kit/Disposable');

import Point = require('text-buffer/point');
import Range = require('text-buffer/range');
import Marker = require('text-buffer/marker');
import MarkerLayer = require('text-buffer/marker-layer');
import ScanFunction = require('text-buffer/scan-function');
import ScanInRangeFunction = require('text-buffer/scan-in-range-function');


namespace TextBuffer {
  export var Point: Point;
  export var Range: Range;
}

class TextBuffer {
  constructor(params: string | { load: boolean, text: string });
  onWillChange(callback: (event: {
    oldRange: Range,
    newRange: Range,
    oldText: string,
    newText: string
  }) => void): Disposable;
  onDidChange(callback: (event: {
    oldRange: Range,
    newRange: Range,
    oldText: string,
    newText: string
  }) => void): Disposable;
  onDidStopChanging: (callback: () => void) => Disposable;
  onDidConflict: (callback: () => void) => Disposable;
  onDidChangeModified(callback: (modified: boolean) => void): Disposable;
  onDidUpdateMarkers: (callback: () => void) => Disposable;
  onDidCreateMarker(callback: (marker: Marker) => void): Disposable;
  onDidChangePath(callback: (path: string) => void): Disposable;
  onDidChangeEncoding(callback: (encoding: string) => void): Disposable;
  onWillSave: (callback: () => void) => Disposable;
  onDidSave(callback: (event: { path: string }) => void): Disposable;
  onDidDelete: (callback: () => void) => Disposable;
  onWillReload: (callback: () => void) => Disposable;
  onDidReload: (callback: () => void) => Disposable;
  onDidDestroy: (callback: () => void) => Disposable;
  onWillThrowWatchError(callback: (errorObject: {
    error: Object,
    handle(): void
  }) => void): Disposable;
  getStoppedChangingDelay(): number;
  isModified(): boolean;
  isInConflict(): boolean;
  getPath(): string;
  setPath(filePath: string): void;
  setEncoding(encoding: string): void;
  getEncoding(): string;
  getUri(): string;
  isEmpty(): boolean;
  getText(): string;
  getTextInRange(range: Range): string;
  getLines(): string[];
  getLastLine(): string;
  lineForRow(row: number): string;
  lineEndingForRow(row: number): '\n' | '\r' | '\r\n' | '';
  lineLengthForRow(row: number): number;
  isRowBlank(row: number): boolean;
  previousNonBlankRow(startRow: number): number;
  nextNonBlankRow(startRow: number): number;
  setText(text: string): Range;
  setTextViaDiff(text: string): any;
  setTextInRange(range: Range, text: string, options?: { normalizeLineEndings?: boolean, undo?: 'skip' }): Range;
  insert(position: Point, text: string, options?: { normalizeLineEndings?: boolean, undo?: 'skip' }): Range;
  append(text: string, options?: { normalizeLineEndings?: boolean, undo?: 'skip' }): Range;
  delete(range: Range): Range;
  deleteRow(row: number): Range;
  deleteRows(startRow: number, endRow: number): Range;
  addMarkerLayer(options: { maintainHistory: boolean }): MarkerLayer;
  getMarkerLayer(id: any): MarkerLayer;
  markRange(range: Range | Point[], properties: {
    reversed?: boolean,
    persistent?: boolean,
    invalidate?: 'never' | 'surround' | 'overlap' | 'inside' | 'touch'
  }): Marker;
  markPosition(position: Point | number[], properties: {
    reversed?: boolean,
    persistent?: boolean,
    invalidate?: 'never' | 'surround' | 'overlap' | 'inside' | 'touch'
  }): Marker;
  getMarkers(): Marker[];
  getMarker(id: number): Marker;
  /**
   * @params params A hash of key-value pairs constraining the set of returned markers.
   * You can query against custom marker properties by listing the desired key-value pairs here.
   * In addition, the following keys are reserved and have special semantics:
   *    startPosition	Only include markers that start at the given Point.
   *    endPosition Only include markers that end at the given Point.
   *    containsPoint Only include markers that contain the given Point, inclusive.
   *    containsRange	Only include markers that contain the given Range, inclusive.
   *    startRow Only include markers that start at the given row Number.
   *    endRow Only include markers that end at the given row Number.
   *    intersectsRow Only include markers that intersect the given row Number.
   */
  findMarkers(params: {
    startPosition?: Point,
    endPosition?: Point,
    containsPoint?: Point,
    containsRange?: Range,
    startRow?: number,
    endRow?: number;
    intersectsRow?: number
  }): Marker[];
  getMarkerCount(): number;
  undo(): void;
  redo(): void;
  transact(fn: () => void): void;
  transact(groupingInterval: number, fn: () => void): void;
  clearUndoStack(): void;
  createCheckpoint(): any;
  revertToCheckpoint(): boolean;
  groupChangesSinceCheckpoint(): boolean;
  scan: ScanFunction;
  backwardsScan: ScanFunction;
  scanInRange: ScanInRangeFunction;
  backwardsScanInRange: ScanInRangeFunction;
  replace(regex: RegExp, replacementText: string): number;
  getRange(): Range;
  getLineCount(): number;
  getLastRow(): number;

  getFirstPosition(): Point;
  getEndPosition(): Point;
  getMaxCharacterIndex(): number;
  rangeForRow(row: number, includeNewline: boolean): Range;
  characterIndexForPosition(position: Point): number;
  positionForCharacterIndex(offset: number): Point;
  clipRange(range: Range): Range;
  clipPosition(position: Point): Point;
  save(): void;
  saveAs(filePath: string): void;
  reload(): void;
}

export = TextBuffer;
}
declare module 'text-buffer/text-buffer' {
import alias = require('text-buffer/text-buffer');
export = alias;
}

// Generated by typings
// Source: ../text-buffer/point.d.ts
declare module 'text-buffer/point' {
class Point {
  static fromObject(object: Point | number[], copy?: boolean): Point;
  static min(point1: Point, point2: Point): Point;
  row: number;
  column: number;
  constructor(row: number, column: number);
  copy(): Point;
  negate(): Point;

  compare(other: Point): Point;
  isEqual(other: Point): boolean;
  isLessThan(other: Point): boolean;
  isLessThanOrEqual(other: Point): boolean;
  isGreaterThan(other: Point): boolean;
  isGreaterThanOrEqual(other: Point): boolean;
  freeze(): void;
  translate(other: Point): Point;
  traverse(other: Point): Point;
  toArray(): number[];
  serialize(): number[];
  toString(): string;
}

export = Point;
}
declare module 'text-buffer/point' {
import alias = require('text-buffer/point');
export = alias;
}

// Generated by typings
// Source: ../text-buffer/range.d.ts
declare module 'text-buffer/range' {
import Point = require('text-buffer/point');

class Range {
  start: Point;
  end: Point;
  static fromObject(object: Range | Point[], copy?: boolean): Range;
  constructor(pointA: Point, pointB: Point);
  copy(): Range;
  negate(): Range;

  static deserialize(array: any): Range;
  serialize(): any;

  isEmpty(): boolean;
  isSingleLine(): boolean;
  getRowCount(): number;
  getRows(): number[];

  freeze(): void;
  union(otherRange: Range): Range;
  translate(startDelta: Point, endDelta?: Point): Range;
  traverse(delta: Point): Range;


  compare(otherRange: Range): Range;
  isEqual(otherRange: Range): boolean;
  coversSameRows(otherRange: Range): boolean;
  intersectsWith(otherRange: Range, exclusive?: boolean): boolean;
  containsRange(otherRange: Range, exclusive?: boolean): boolean;
  containsPoint(point: Point, exclusive?: boolean): boolean;
  intersectsRow(row: number): boolean;
  intersectsRowRange(startRow: number, endRow: number): boolean;
  toString(): string;

}

export = Range;
}
declare module 'text-buffer/range' {
import alias = require('text-buffer/range');
export = alias;
}

// Generated by typings
// Source: ../node-pathwatcher/file.d.ts
declare module 'node-pathwatcher/file' {

import Directory = require('node-pathwatcher/directory');

class File {
  constructor(filePath: string, symlink?: boolean);
  create(): PromiseLike<boolean>;
  onDidChange(callback: () => void): void;
  onDidRename(callback: () => void): void;
  onDidDelete(callback: () => void): void;
  onWillThrowWatchError(callback: (errorObject: {
    error: Object;
    handle(): void
  }) => void): void;
  isFile(): boolean;
  isDirectory(): boolean;
  isSymbolicLink(): boolean;
  exists(): PromiseLike<boolean>;
  existsSync(): boolean;
  getDigest(): PromiseLike<string>;
  getDigestSync(): string;
  setEncoding(encoding: string): void;
  getEncoding(): string;
  getPath(): string;
  getRealPathSync(): string;
  getRealPath(): PromiseLike<string>;
  getBaseName(): string;
  getParent(): Directory;
  read(flushCache: boolean): PromiseLike<string>;
  write(text: string): PromiseLike<void>;
  writeSync(text: string): void;
}

export = File;
}
declare module 'node-pathwatcher/file' {
import alias = require('node-pathwatcher/file');
export = alias;
}

// Generated by typings
// Source: ../node-pathwatcher/directory.d.ts
declare module 'node-pathwatcher/directory' {

import Disposable = require('event-kit/disposable');

class Directory {
  constructor(directoryPath: string, symlink?: boolean);
  create(mode?: number): PromiseLike<boolean>;
  onDidChange: (callback: () => void) => Disposable;
  isFile(): boolean;
  isDirectory(): boolean;
  isSymbolicLink(): boolean;
  exists(): PromiseLike<boolean>;
  existsSync(): boolean;
  isRoot(): boolean;
  getPath(): string;
  getRealPathSync(): string;
  getBaseName(): string;
  relativize(): string;
  getParent(): Directory;
  getFile(filename: string): File;
  getSubdirectory(dirname: string): Directory;
  getEntriesSync(): (File | Directory)[];
  getEntries(callback: (error: Error, entries: (File | Directory)[]) => void): void;
  contains(pathToCheck: string): boolean;
}

export = Directory;
}
declare module 'node-pathwatcher/directory' {
import alias = require('node-pathwatcher/directory');
export = alias;
}

// Generated by typings
// Source: ../event-kit/emitter.d.ts
declare module 'event-kit/emitter' {
import Disposable = require('event-kit/disposable');
class Emitter {
  clear(): void;
  dispose(): void;
  on(eventName: string, handler: (value: any) => void): Disposable;
  preempt(eventName: string, handler: (value: any) => void): Disposable;
  emit(eventName: string, value: any): void;
}

export = Emitter;
}
declare module 'event-kit/emitter' {
import alias = require('event-kit/emitter');
export = alias;
}

// Generated by typings
// Source: ../event-kit/disposable.d.ts
declare module 'event-kit/disposable' {
class Disposable {
  static isDisposable(object: Object): boolean;
  constructor(disposalAction: Function);
  dispose(): void;
}

export = Disposable;
}
declare module 'event-kit/disposable' {
import alias = require('event-kit/disposable');
export = alias;
}

// Generated by typings
// Source: ../event-kit/composite-disposable.d.ts
declare module 'event-kit/composite-disposable' {
class CompositeDisposable {
  constructor(...disposables: { dispose: () => any }[]);
  dispose(): void;
  add(...disposables: { dispose: () => any }[]): void;
  remove(disposable: { dispose: () => any }): void;
  clear(): void;
}

export = CompositeDisposable;
}
declare module 'event-kit/composite-disposable' {
import alias = require('event-kit/composite-disposable');
export = alias;
}

// Generated by typings
// Source: ../atom-keymap/key-binding.d.ts
declare module 'atom-keymap/key-binding' {
class KeyBinding {
  enabled: boolean;
  matches(keystroke: string): boolean;
  compare(keyBinding: KeyBinding): number;
}

export = KeyBinding;
}
declare module 'atom-keymap/key-binding' {
import alias = require('atom-keymap/key-binding');
export = alias;
}

// Generated by typings
// Source: ../atom-keymap/keymap-manager.d.ts
declare module 'atom-keymap/keymap-manager' {
import Disposable = require('event-kit/disposable');
import KeyBinding = require('atom-keymap/key-binding');

interface KeyOption {
  ctrl?: boolean;
  alt?: boolean;
  shift?: boolean;
  cmd?: boolean;
  which?: number;
  target: any; // ELEMNT?
}

class KeymapManager {
  static buildKeydownEvent(key: string, options?: KeyOption): void;
  constructor(options: { defaultTarget?: any });
  clear(): void;
  destroy(): void;

  // Event Subscription
  onDidMatchBinding(callback: (event: {
    keystrokes: string;
    binding: KeyBinding;
    keyboardEventTarget: any; // DOM element
  }) => void): Disposable;
  onDidPartiallyMatchBindings(callback: (event: {
    keystrokes: string;
    partiallyMatchedBindings: KeyBinding[];
    keyboardEventTarget: any;
  }) => void): Disposable;
  onDidFailToMatchBinding(callback: (event: {
    keystrokes: string;
    keyboardEventTarget: any;
  }) => void): Disposable;
  onDidFailToReadFile(callback: (error: {
    message: string;
    stack: string;
  }) => void): Disposable;

  // Adding and Removing Bindings
  add(source: string, bindings: Object, priority: number): void;

  // Accessing Bindings
  getKeyBindings(): KeyBinding[];
  findKeyBindings(params: {
    keystrokes: string;
    command: string;
    target: any
  }): KeyBinding[];
  loadKeymap(path: string, options: {
    watch: boolean;
    priority: number;
  }): void;
  watchKeymap(path: string, options: {
    priority: number;
  }): void;

  // Managing Keyboard Events
  handleKeyboardEvent(event: KeyboardEvent): void;
  keystrokeForKeyboardEvent(event: KeyboardEvent): string;
  getPartialMatchTimeout(): number;
}

export = KeymapManager;
}
declare module 'atom-keymap/keymap-manager' {
import alias = require('atom-keymap/keymap-manager');
export = alias;
}

// Generated by typings
// Source: ../first-mate/grammar.d.ts
declare module 'first-mate/grammar' {
import Disposable = require('event-kit/disposable');

import GrammarRegistry = require('first-mate/grammar-registry');

class Grammar {
  constructor(registry: GrammarRegistry, options?: Object);

  onDidUpdate: (callback: () => void) => Disposable;
  tokenizeLines(text: string): any[];
  tokenizeLine(line: string, ruleStack?: any[], firstLine?: boolean): {
    line: string;
    tags: number[];
    tokens(): any;
    ruleStack: any[];
  };
}

export = Grammar;
}
declare module 'first-mate/grammar' {
import alias = require('first-mate/grammar');
export = alias;
}

// Generated by typings
// Source: ../first-mate/grammar-event-handler.d.ts
declare module 'first-mate/grammar-event-handler' {
import Disposable = require('event-kit/disposable');
import Grammar = require('first-mate/grammar');

interface GrammarEventHandler {
  (callback: (grammar: Grammar) => void): Disposable;
}


export = GrammarEventHandler;
}
declare module 'first-mate/grammar-event-handler' {
import alias = require('first-mate/grammar-event-handler');
export = alias;
}

// Generated by typings
// Source: ../first-mate/grammar-registry.d.ts
declare module 'first-mate/grammar-registry' {
import Disposable = require('event-kit/disposable');

import Grammar = require('first-mate/grammar');

import GrammarEventHandler = require('first-mate/grammar-event-handler');

class GrammarRegistry {
  onDidAddGrammar: GrammarEventHandler;
  onDidUpdateGrammar: GrammarEventHandler;
  getGrammars(): Grammar[];
  grammarForScopeName(scopeName: string): Grammar;
  addGrammar(grammar: Grammar): Disposable;
  removeGrammarForScopeName(scopeName: string): Grammar;
  readGrammarSync(grammarPath: string): Grammar;
  readGrammar(grammarPath: string, callback: (err: Error, grammar: Grammar) => void): void;
  loadGrammarSync(grammarPath: string): Grammar;
  loadGrammar(grammarPath: string, callback: (err: Error, grammar: Grammar) => void): void;
}

export = GrammarRegistry;
}
declare module 'first-mate/grammar-registry' {
import alias = require('first-mate/grammar-registry');
export = alias;
}

// Generated by typings
// Source: ../event-kit/event-callback.d.ts
declare module 'event-kit/event-callback' {
interface EventCallback {
  (event: any): void;
}

export = EventCallback;
}
declare module 'event-kit/event-callback' {
import alias = require('event-kit/event-callback');
export = alias;
}

// Generated by typings
// Source: command-registry.d.ts
declare module '~atom/command-registry' {
import EventCallback = require('event-kit/event-callback');

interface CommandRegistry {
  add(target: string, commandName: string, callback: EventCallback): any;
  findCommands(params: { target: any }): Array<{ name: string, displayName: string }>;
  dispatch(target: any, commandName: string): void;
  onWillDispatch(callback: EventCallback): void;
  onDidDispatch(callback: EventCallback): void;
}

export = CommandRegistry;
}
declare module 'atom/command-registry' {
import alias = require('~atom/command-registry');
export = alias;
}

// Generated by typings
// Source: scope-descriptor.d.ts
declare module '~atom/scope-descriptor' {
class ScopeDescriptor {
  constructor(options?: { scopes: string[] });
  getScopesArray(): string[];
}

export = ScopeDescriptor;
}
declare module 'atom/scope-descriptor' {
import alias = require('~atom/scope-descriptor');
export = alias;
}

// Generated by typings
// Source: config.d.ts
declare module '~atom/config' {
import ScopeDescriptor = require('~atom/scope-descriptor');

interface ConfigOption {
  sources?: string[];
  excludeSources?: string[];
  scope?: ScopeDescriptor;
}

interface Config {
  get<T>(keyPath: string, options?: ConfigOption): T;
  set(keyPath: string, value: any, options?: { scopeSelector?: string, source?: string }): boolean;
  unset(keyPath: string, options?: { scopeSelector?: string, source?: string }): void;
  // Extended Methods
  getAll<T>(keyPath: string, options?: ConfigOption): { scopeDescriptor: ScopeDescriptor, value: T }[];
  getSources(): string[];
  getSchema(keyPath): any;
  getUserConfigPath(): string;
  transact(callback: () => void): void;
}

export = Config;
}
declare module 'atom/config' {
import alias = require('~atom/config');
export = alias;
}

// Generated by typings
// Source: clipboard.d.ts
declare module '~atom/clipboard' {
class Clipboard {
  write(text: string, metadata?: any): void;
  read(): string;
  readWithMetadata(): {
    text: string;
    metadata: any;
  };
}

export = Clipboard;
}
declare module 'atom/clipboard' {
import alias = require('~atom/clipboard');
export = alias;
}

// Generated by typings
// Source: context-menu-manager.d.ts
declare module '~atom/context-menu-manager' {
import Disposable = require('event-kit/disposable');
import EventCallback = require('event-kit/event-callback');

interface ContextMenuItem {
  label?: string;
  command?: string;
  enabled?: boolean;
  submenu?: ContextMenuItem[];
  type?: 'separator';
  visible?: boolean;
  created?: (event: EventCallback) => void;
  shouldDisplay?: (event: EventCallback) => void;
}

class ContextMenuManager {
  add(itemsBySelector: ContextMenuItem): Disposable;
}

export = ContextMenuManager;
}
declare module 'atom/context-menu-manager' {
import alias = require('~atom/context-menu-manager');
export = alias;
}

// Generated by typings
// Source: menu-manager.d.ts
declare module '~atom/menu-manager' {
import Disposable = require('event-kit/disposable');

interface MenuItem {
  label: string;
  submenu?: MenuItem[];
  command?: string;
}

class MenuManager {
  add(items: MenuItem): Disposable;
  update(): void;
}
export = MenuManager;
}
declare module 'atom/menu-manager' {
import alias = require('~atom/menu-manager');
export = alias;
}

// Generated by typings
// Source: tooltip-manager.d.ts
declare module '~atom/tooltip-manager' {
import Disposable = require('event-kit/disposable');

// Available in lib.d.ts?
interface JSTooltipOption {
  animation?: boolean;
  container?: string | boolean;
  delay?: number | { show: number, hide: number };
  html?: boolean;
  placement?: string | ((tooltipDomNode: any, triggeringElementDomNode: any) => string);
  selector?: string | boolean;
  template?: string;
  title?: string | (() => string);
  trigger?: string;
  viewport?: string | { selector: string, padding: number } | ((triggeringElementDomNode: any) => string | { selector: string, padding: number });
}

interface TooltipOption extends JSTooltipOption {
  keyBindingCommand?: string;
  keyBindingTarget?: HTMLElement;
}


class TooltipManager {
  add(target: HTMLElement, options: TooltipOption): Disposable;
}

export = TooltipManager;
}
declare module 'atom/tooltip-manager' {
import alias = require('~atom/tooltip-manager');
export = alias;
}

// Generated by typings
// Source: notification-manager.d.ts
declare module '~atom/notification-manager' {
import Disposable = require('event-kit/disposable');
import Notification = require('~atom/notification');

class NotificationManager {
  onDidAddNotification(callback: (notification: Notification) => void): Disposable;
  addSuccess(message: string, options?: {
    detail?: string;
    dismissable?: boolean;
    icon?: string;
  }): void;
  addInfo(message: string, options?: {
    detail?: string;
    dismissable?: boolean;
    icon?: string;
  }): void;
  addWarning(message: string, options?: {
    detail?: string;
    dismissable?: boolean;
    icon?: string;
  }): void;
  addError(message: string, options?: {
    detail?: string;
    dismissable?: boolean;
    icon?: string;
  }): void;
  addFatalError(message: string, options?: {
    detail?: string;
    dismissable?: boolean;
    icon?: string;
  }): void;
  getNotifications(): Notification[];
}

export = NotificationManager;
}
declare module 'atom/notification-manager' {
import alias = require('~atom/notification-manager');
export = alias;
}

// Generated by typings
// Source: project.d.ts
declare module '~atom/project' {
import Disposable = require('event-kit/disposable');
import Directory = require('node-pathwatcher/directory');

import GitRepository = require('~atom/git-repository');

class Project {
  // Event Subscription
  onDidChangePaths(callback: (projectPaths: string[]) => void): Disposable;

  // Accessing the git repository
  /**
   * Will be removed in 2.0
   */
  getRepositories(): GitRepository[];
  repositoryForDirectory(directory: Directory): PromiseLike<GitRepository>; // Was Repository. Likely API mistake.
  getPaths(): string[];
  setPaths(projectPaths: string[]): void;
  addPath(projectPath: string): void;
  removePath(projectPath: string): void;
  getDirectories(): Directory[];
  relativizePath(fullPath: string): { projectPath: string, relativePath: string }[];
  contains(pathToCheck: string): boolean;
}

export = Project;
}
declare module 'atom/project' {
import alias = require('~atom/project');
export = alias;
}

// Generated by typings
// Source: ../event-kit/event-handler.d.ts
declare module 'event-kit/event-handler' {
import Disposable = require('event-kit/disposable');

interface EventHandler {
  (callback: () => void): Disposable;
}

export = EventHandler;
}
declare module 'event-kit/event-handler' {
import alias = require('event-kit/event-handler');
export = alias;
}

// Generated by typings
// Source: package.d.ts
declare module '~atom/package' {
import EventHandler = require('event-kit/event-handler');

interface Package {
  onDidDeactivate: EventHandler;
  isCompatible(): boolean;
  rebuild(): PromiseLike<{
    code: any,
    stdout: any,
    stderr: any
  }>;
  getBuildFailureOutput(): string;
}

export = Package;
}
declare module 'atom/package' {
import alias = require('~atom/package');
export = alias;
}

// Generated by typings
// Source: package-manager.d.ts
declare module '~atom/package-manager' {
import Disposable = require('event-kit/disposable');
import EventHandler = require('event-kit/event-handler');
import Package = require('~atom/package');

class PackageManager {
  onDidLoadInitialPackages: EventHandler;
  onDidActivateInitialPackages: EventHandler;
  onDidActivatePackage(callback: (activatedPackage: Package) => void): Disposable;
  onDidDeactivatePackage(callback: (deactivatedPackage: Package) => void): Disposable;
  onDidLoadPackage(callback: (loadedPackage: Package) => void): Disposable;
  onDidUnloadPackage(callback: (unloadedPackage: Package) => void): Disposable;
  getApmPath(): string;
  getPackageDirPaths(): string[];
  resolvePackagePath(name: string): string;
  isBundledPackage(name: string): boolean;
  enablePackage(name: string): Package;
  disablePackage(name: string): Package;
  isPackageDisabled(name: string): boolean;
  getActivePackages(): Package[];
  getActivePackage(name: string): Package;
  isPackageActive(name: string): boolean;
  getLoadedPackages(): Package[];
  getLoadedPackage(name: string): Package;
  isPackageLoaded(name: string): boolean;
  getAvailablePackagePaths(): string[];
  getAvailablePackageNames(): string[];
  getAvailablePackageMetadata(): string[];
}

export = PackageManager;
}
declare module 'atom/package-manager' {
import alias = require('~atom/package-manager');
export = alias;
}

// Generated by typings
// Source: theme-manager.d.ts
declare module '~atom/theme-manager' {
import EventHandler = require('event-kit/event-handler');

class ThemeManager {
  onDidChangeActiveThemes: EventHandler;
  getLoadedThemeNames(): string[];
  getLoadedThemes(): any[];
  getActiveThemeNames(): string[];
  getActiveThemes(): any[];
  getEnabledThemeNames(): string[];
}

export = ThemeManager;
}
declare module 'atom/theme-manager' {
import alias = require('~atom/theme-manager');
export = alias;
}

// Generated by typings
// Source: style-manager.d.ts
declare module '~atom/style-manager' {
import Disposable = require('event-kit/disposable');

interface StyleElement extends HTMLStyleElement {
  sourcePath: string;
  context: string;
}

class StyleManager {
  observeStyleElements(callback: (styleElement: StyleElement) => void): Disposable;
  onDidAddSytleElement(callback: (styleElement: StyleElement) => void): Disposable;
  onDidRemoveSytleElement(callback: (styleElement: HTMLStyleElement) => void): Disposable;
  onDidUpdateSytleElement(callback: (styleElement: StyleElement) => void): Disposable;
  getStyleElements(): StyleElement[];
  getUserStyleSheetPath(): string;
}

export = StyleManager;
}
declare module 'atom/style-manager' {
import alias = require('~atom/style-manager');
export = alias;
}

// Generated by typings
// Source: atom-environment.d.ts
declare module '~atom/atom-environment' {
import Disposable = require('event-kit/disposable');
import EventHandler = require('event-kit/event-handler');
import KeymapManager = require('atom-keymap/keymap-manager');
import GrammarRegistry = require('first-mate/grammar-registry');

import CommandRegistry = require('~atom/command-registry');
import Config = require('~atom/config');
import Clipboard = require('~atom/clipboard');
import ContextMenuManager = require('~atom/context-menu-manager');
import MenuManager = require('~atom/menu-manager');
import TooltipManager = require('~atom/tooltip-manager');
import NotificationManager = require('~atom/notification-manager');
import Project = require('~atom/project');
import PackageManager = require('~atom/package-manager');
import ThemeManager = require('~atom/theme-manager');
import StyleManager = require('~atom/style-manager');
import DeserializerManager = require('~atom/deserializer-manager');
import ViewRegistry = require('~atom/view-registry');
import Workspace = require('~atom/workspace');

interface AtomEnvironment {
  commands: CommandRegistry;
  config: Config;
  clipboard: Clipboard;
  contextMenu: ContextMenuManager;
  menu: MenuManager;
  keymaps: KeymapManager;
  tooltips: TooltipManager;
  notifications: NotificationManager;
  project: Project;
  grammars: GrammarRegistry;
  packages: PackageManager;
  themes: ThemeManager;
  styles: StyleManager;
  deserializers: DeserializerManager;
  views: ViewRegistry;
  workspace: Workspace;
  // Extended Methods
  onDidBeep: EventHandler;
  onWillThrowError(callback: (event: {
    originalError: Object;
    message: string;
    url: string;
    line: number;
    column: number;
    preventDefault(): void;
  }) => void): Disposable;
  onDidThrowError(callback: (event: {
    originalError: Object;
    message: string;
    url: string;
    line: number;
    column: number;
  }) => void): Disposable;
}

export = AtomEnvironment;
}
declare module 'atom/atom-environment' {
import alias = require('~atom/atom-environment');
export = alias;
}

// Generated by typings
// Source: deserializer-manager.d.ts
declare module '~atom/deserializer-manager' {
import AtomEnvironment = require('~atom/atom-environment');

class DeserializerManager {
  add(deserializers: { name: string, deserialize: (serializedState: any, atom: AtomEnvironment) => any }): void;
  deserialize(state: Object): void;
}

export = DeserializerManager;
}
declare module 'atom/deserializer-manager' {
import alias = require('~atom/deserializer-manager');
export = alias;
}

// Generated by typings
// Source: view-registry.d.ts
declare module '~atom/view-registry' {
import Disposable = require('event-kit/disposable');

class ViewRegistry {
  addViewProvider(createView: () => HTMLElement): Disposable;
  addViewProvider(modelConstructor: Function, createView: () => HTMLElement): Disposable;
  getView(object: Object): any; // DOM element
}

export = ViewRegistry;
}
declare module 'atom/view-registry' {
import alias = require('~atom/view-registry');
export = alias;
}

// Generated by typings
// Source: workspace.d.ts
declare module '~atom/workspace' {
interface Workspace {
  addModalPanel(option: any);
}

export = Workspace;
}
declare module 'atom/workspace' {
import alias = require('~atom/workspace');
export = alias;
}

// Generated by typings
// Source: task.d.ts
declare module '~atom/task' {
class Task {
  // Methods
  static once(taskPath: string, args: any[]): Task;
  constructor(taskPath: string);
  start(args: any[], callback?: Function): void;
  send(message: any): void;
  on(eventName: string, callback: Function): void;
  once(taskPath: string, args: any[]): Task;
  terminate(): void;
}
export = Task;
}
declare module 'atom/task' {
import alias = require('~atom/task');
export = alias;
}

// Generated by typings
// Source: cursor.d.ts
declare module '~atom/cursor' {
import Disposable = require('event-kit/disposable');
import Point = require('text-buffer/point');
import TextEditorMarker = require('~atom/text-editor-marker');
import CursorChangeEventHandler = require('~atom/cursor-change-event-handler');
import ScopeDescriptor = require('~atom/scope-descriptor');

interface Cursor {
  onDidChangePosition: CursorChangeEventHandler;
  onDidDestroy: (callback: () => void) => Disposable;
  onDidChangeVisibility(callback: (visibility: boolean) => void): Disposable;
  setScreenPosition(screenPosition: number[], options?: { autoscroll: boolean }): void;
  getScreenPosition(): Point;
  setBufferPosition(bufferPosition: number[], options?: { autoscroll: boolean }): void;
  getBufferPosition(): Point;
  getScreenRow(): number;
  getScreenColumn(): number;
  getBufferRow(): number;
  getBufferColumn(): number;
  getCurrentBufferLine(): number;
  isAtBeginningOfLine(): boolean;
  isAtEndOfLine(): boolean;
  getMarker(): TextEditorMarker;
  isSurroundedByWhitespace(): boolean;
  isBetweenWOrdAndNonWord(): boolean;
  isInsideWord(option?: { wordRegex: RegExp }): boolean;
  getIndentLevel(): number;
  getScopeDescriptor(): ScopeDescriptor;
  hasPrecedingCharactersOnLine(): boolean;
  isLastCursor(): boolean;
  moveUp(rowCount?: number, options?: { moveToEndOfSelection }): void;
  moveDown(rowCount?: number, options?: { moveToEndOfSelection }): void;
  moveLeft(columnCount?: number, options?: { moveToEndOfSelection }): void;
  moveRight(columnCount?: number, options?: { moveToEndOfSelection }): void;
  moveToTop(): void;
  moveToBottom(): void;
  moveToBeginningOfScreenLine(): void;
  moveToBeginningOfLine(): void;
  moveToFirstCharacterOfLine(): void;
  moveToEndOfScreenLine(): void;
  moveToEndOfLine(): void;
  moveToBeginningOfWord(): void;
  moveToEndOfWord(): void;
  moveToBeginningOfNextWord(): void;
  moveToPreviousWordBoundary(): void;
  moveToNextWordBoundary(): void;
  moveToPreviousSubwordBoundary(): void;
  moveToNextSubwordBoundary(): void;
  skipLeadingWhitespace(): void;
  moveToBeginningOfNextParagraph(): void;
  moveToBeginningOfPreviousParagraph(): void;
  getPreviousWordBoundaryBufferPosition(options?: { wordRegex: RegExp }): any;
  getNextWordBoundaryBufferPosition(options?: { wordRegex: RegExp }): any;
  getBeginningOfCurrentWordBufferPosition(options?: {
    wordRegex: RegExp,
    includeNonWordCharacters: boolean,
    allowPrevious: boolean
  }): Range;
  getEndOfCurrentWordBufferPosition(options?: {
    wordRegex: RegExp,
    includeNonWordCharacters: boolean
  }): Range;
  getBeginningOfNextWordBufferPosition(options?: { wordRegex: RegExp }): Range;
  getCurrentWordBufferRange(options?: { wordRegex: RegExp }): Range;
  getCurrentLineBufferRange(options?: { includeNewLine: boolean }): Range;
  getCurrentParagraphBufferRange(): Range;
  getCurrentWordPrefix(): string;
  setVisible(): void;
  isVisible(): boolean;
  compare(otherCursor: Cursor): number;
  clearAutoscroll(): void;
  clearSelection(): void;
  wordRegExp(options?: { includeNonWordCharacters?: boolean }): RegExp;
  subwordRegExp(options?: { backwards?: boolean }): RegExp;
}
export = Cursor;
}
declare module 'atom/cursor' {
import alias = require('~atom/cursor');
export = alias;
}

// Generated by typings
// Source: decoration.d.ts
declare module '~atom/decoration' {
import Disposable = require('event-kit/disposable');

class Decoration {
  destroy(): void;
  onDidChangeProperties(callback: (event: {
    oldProperties: Object;
    newProperties: Object;
  }) => void): Disposable;
  onDidDestroy: (callback: () => void) => Disposable;
  getId(): any;
  getMarker(): any; // Marker;
  getProperties(): Object;
  setProperties(newProperties: Object): void;
}
export = Decoration;
}
declare module 'atom/decoration' {
import alias = require('~atom/decoration');
export = alias;
}

// Generated by typings
// Source: gutter.d.ts
declare module '~atom/gutter' {
import Disposable = require('event-kit/disposable');

import TextEditorMarker = require('~atom/text-editor-marker');
import Decoration = require('~atom/decoration');

interface Gutter {
  // Gutter Destruction
  destroy(): void;

  // Event Subscription
  onDidChangeVisible(callback: (gutter: Gutter) => void): Disposable;
  onDidDestroy: (callback: () => void) => Disposable;

  // Visibility
  hide(): void;
  show(): void;
  isVisible(): boolean;
  decorateMarker(marker: TextEditorMarker, decorationParams: { type: 'line-number' | 'gutter' }): Decoration;
}
export = Gutter;
}
declare module 'atom/gutter' {
import alias = require('~atom/gutter');
export = alias;
}

// Generated by typings
// Source: text-editor-marker.d.ts
declare module '~atom/text-editor-marker' {
import Point = require('text-buffer/point');
import Range = require('text-buffer/range');
import Disposable = require('event-kit/disposable');

class TextEditorMarker {
  destroy(): void;
  copy(properties?: Object): TextEditorMarker;
  onDidChange(callback: (event: {
    oldHeadBufferPosition: Point;
    newHeadBufferPosition: Point;
    oldTailBufferPosition: Point;
    newTailBufferPosition: Point;
    oldHeadScreenPosition: Point;
    newHeadScreenPosition: Point;
    oldTailScreenPosition: Point;
    newTailScreenPosition: Point;
    wasValid: boolean;
    isValid: boolean;
    hadTail: boolean;
    hasTail: boolean;
    oldProperties: Object;
    newProperties: Object;
    textChanged: boolean;
  }) => void): Disposable;
  onDidDestroy: (callback: () => void) => Disposable;
  isValid(): boolean;
  isDestroyed(): boolean;
  isReversed(): boolean;
  getInvalidationStrategy(): string;
  getProperties(): Object;
  setProperties(properties: Object): void;
  isEqual(other: TextEditorMarker): boolean;
  compare(other: TextEditorMarker): number;
  getBufferRange(): Range;
  setBufferRange(bufferRange: Range, properties?: { reversed: boolean }): void;
  getScreenRange(): Range;
  setScreenRange(bufferRange: Range, properties?: { reversed: boolean }): void;
  getStartBufferPosition(): Point;
  getStartScreenPosition(): Point;
  getEndBufferPosition(): Point;
  getEndScreenPosition(): Point;

  // Extended Methods
  getHeadBufferPosition(): Point;
  getHeadBufferPosition(bufferPosition: Point, properties?: Object): void;
  getHeadScreenPosition(): Point;
  getHeadScreenPosition(screenPosition: Point, properties?: Object): void;
  getTailBufferPosition(): Point;
  getTailBufferPosition(bufferPosition: Point, properties?: Object): void;
  getTailScreenPosition(): Point;
  getTailScreenPosition(screenPosition: Point, properties?: Object): void;
  hasTail(): boolean;
  plantTail(properties?: Object): void;
  clearTail(properties?: Object): void;
}

export = TextEditorMarker;
}
declare module 'atom/text-editor-marker' {
import alias = require('~atom/text-editor-marker');
export = alias;
}

// Generated by typings
// Source: text-editor-marker-layer.d.ts
declare module '~atom/text-editor-marker-layer' {
import Disposable = require('event-kit/disposable');
import EventHandler = require('event-kit/event-handler');
import Point = require('text-buffer/point');
import Range = require('text-buffer/range');
import TextEditorMarker = require('~atom/text-editor-marker');

class TextEditorMarkerLayer {
  // Lifecycle
  destroy(): void;

  // Querying
  getMarker(): TextEditorMarker;
  getMarkers(): TextEditorMarker[];
  getMarkerCount(): number;
  findMarkers(properties: {
    startBufferRow: number,
    endBufferRow: number,
    containsBufferRange: Range | Point[],
    containsBufferPosition: Point | number[]
  }): TextEditorMarker[];

  // Marker creation
  markBufferRange(range: Range | Point[], properties: {
    maintainHistory?: boolean,
    reversed?: boolean,
    persistent?: boolean,
    invalidate?: 'never' | 'surround' | 'overlap' | 'inside' | 'touch'
  }): TextEditorMarker;
  markScreenRange(range: Range, properties: {
    maintainHistory?: boolean,
    reversed?: boolean,
    persistent?: boolean,
    invalidate?: 'never' | 'surround' | 'overlap' | 'inside' | 'touch'
  }): TextEditorMarker;
  markBufferPosition(position: Point | number[], options?: {
    reversed?: boolean,
    persistent?: boolean,
    invalidate?: 'never' | 'surround' | 'overlap' | 'inside' | 'touch'
  }): TextEditorMarker;
  markScreenPosition(position: Point | number[], options?: {
    reversed?: boolean,
    persistent?: boolean,
    invalidate?: 'never' | 'surround' | 'overlap' | 'inside' | 'touch'
  }): TextEditorMarker;

  // Event Subscription
  onDidUpdate: EventHandler;
  onDidCreateMarker(callback: (marker: TextEditorMarker) => void): Disposable;
  onDidDestroy: EventHandler;
}

export = TextEditorMarkerLayer;
}
declare module 'atom/text-editor-marker-layer' {
import alias = require('~atom/text-editor-marker-layer');
export = alias;
}

// Generated by typings
// Source: cursor-change-event-handler.d.ts
declare module '~atom/cursor-change-event-handler' {
import Disposable = require('event-kit/disposable');
import Point = require('text-buffer/point');
import Cursor = require('~atom/cursor');

interface CursorChangeEventHandler {
  (callback: (event: {
    oldBufferPosition: Point,
    oldScrrenPosition: Point,
    newBufferPosition: Point,
    newScrrenPosition: Point,
    textChanged: boolean,
    cursor: Cursor
  }) => void): Disposable;
}
export = CursorChangeEventHandler;
}
declare module 'atom/cursor-change-event-handler' {
import alias = require('~atom/cursor-change-event-handler');
export = alias;
}

// Generated by typings
// Source: ../text-buffer/set-range-option.d.ts
declare module 'text-buffer/set-range-option' {
interface SetRangeOption {
  preserveFolds: boolean;
  autoScroll: boolean;
}

export = SetRangeOption;
}
declare module 'text-buffer/set-range-option' {
import alias = require('text-buffer/set-range-option');
export = alias;
}

// Generated by typings
// Source: selection.d.ts
declare module '~atom/selection' {
import Disposable = require('event-kit/disposable');
import EventHandler = require('event-kit/event-handler');
import Point = require('text-buffer/point');
import Range = require('text-buffer/range');
import SetRangeOption = require('text-buffer/set-range-option');

class Selection {
  onDidChangeRange(callback: (event: {
    oldBufferRange: Range;
    oldScreenRange: Range;
    newBufferRange: Range;
    newScreenRange: Range;
    selection: Selection
  }) => void): Disposable;
  onDidDestroy: EventHandler;
  getScreenRange(): Range;
  setScreenRange(screenRange: Range, options?: SetRangeOption): void;
  getbufferRange(): Range;
  setbufferRange(bufferRange: Range, options?: SetRangeOption): void;
  getBufferRowRange(): any;
  isEmpty(): boolean;
  isReversed(): boolean;
  isSingleScreenLine(): boolean;
  getText(): string;
  intersectsBufferRange(bufferRange: Range): boolean;
  intersectsWith(otherSelection: Selection): boolean;
  clear(options?: { autoScroll: boolean }): void;
  selectToScreenPosition(position: Point): void;
  selectToBufferPosition(position: Point): void;
  selectRight(columnCount?: number): void;
  selectLeft(columnCount?: number): void;
  selectUp(rowCount?: number): void;
  selectDown(rowCount?: number): void;
  selectToTop(): void;
  selectToBottom(): void;
  selectAll(): void;
  selectToBeginningOfLine(): void;
  selectToFirstCharactorOfLine(): void;
  selectToEndOfLine(): void;
  selectToEndOfBufferLine(): void;
  selectToBeginningOfWord(): void;
  selectToEndOfWord(): void;
  selectToBeginningOfNextWord(): void;
  selectToPreviousWordBoundary(): void;
  selectToNextWordBoundary(): void;
  selectToPreviousSubwordBoundary(): void;
  selectToNextSubwordBoundary(): void;
  selectToBeginningOfNextParagraph(): void;
  selectToBeginningOfPreviousParagraph(): void;
  selectWord(): void;
  expandOverWord(): void;
  selectLine(row: number): void;
  expandOverLine(): void;
  insertText(text: string, options?: {
    select: boolean;
    autoIndent: boolean;
    autoIndentNewLine: boolean;
    autoDecreaseIndent: boolean;
    normalizeLineEndings?: boolean;
    undo: 'skip'
  }): void;
  backspace(): void;
  deleteToPreviousWordBoundary(): void;
  deleteToNextWordBoundary(): void;
  deleteToBeginningOfWord(): void;
  deleteToBeginningOfLine(): void;
  delete(): void;
  deleteToEndOfLine(): void;
  deleteToEndOfWord(): void;
  deleteToBeginningOfSubword(): void;
  deleteToEndOfSubword(): void;
  deleteLine(): void;
  joinLines(): void;
  outdentSelectedRows(): void;
  autoIndentSelectedRows(): void;
  toggleLineComments(): void;
  cutToEndOfLine(): void;
  cutToEndOfBufferLine(): void;
  cut(maintainClipboard: boolean, fullLine: boolean): void;
  copy(maintainClipboard: boolean, fullLine: boolean): void;
  fold(): void;
  indentSelectedRows(): void;
  addSelectionBelow(): void;
  addSelectionAbove(): void;
  merge(otherSelection: Selection, options?: SetRangeOption): void;
  compare(otherSelection: Selection): number;
}
export = Selection;
}
declare module 'atom/selection' {
import alias = require('~atom/selection');
export = alias;
}

// Generated by typings
// Source: selection-change-event-handler.d.ts
declare module '~atom/selection-change-event-handler' {
import Disposable = require('event-kit/disposable');
import Range = require('text-buffer/range');
import Selection = require('~atom/selection');

interface SelectionChangeEventHandler {
  (callback: (event: {
    oldBufferRange: Range,
    oldScreenRange: Range,
    newBufferRange: Range,
    newScreenRange: Range,
    selection: Selection
  }) => void): Disposable;
}

export = SelectionChangeEventHandler;
}
declare module 'atom/selection-change-event-handler' {
import alias = require('~atom/selection-change-event-handler');
export = alias;
}

// Generated by typings
// Source: clip-screen-position-option.d.ts
declare module '~atom/clip-screen-position-option' {
interface ClipScreenPositionOption {
  wrapBeyondNewlines?: boolean;
  wrapAtSoftNewlines?: boolean;
  screenLine?: boolean;
}
export = ClipScreenPositionOption;
}
declare module 'atom/clip-screen-position-option' {
import alias = require('~atom/clip-screen-position-option');
export = alias;
}

// Generated by typings
// Source: text-editor.d.ts
declare module '~atom/text-editor' {
import Disposable = require('event-kit/disposable');
import TextBuffer = require('text-buffer/text-buffer');
import Point = require('text-buffer/point');
import Range = require('text-buffer/range');
import MarkerLayer = require('text-buffer/marker-layer');
import ScanFunction = require('text-buffer/scan-function');
import ScanInRangeFunction = require('text-buffer/scan-in-range-function');
import Grammar = require('first-mate/grammar');

import Cursor = require('~atom/cursor');
import Decoration = require('~atom/decoration');
import Gutter = require('~atom/gutter');
import TextEditorMarker = require('~atom/text-editor-marker');
import TextEditorMarkerLayer = require('~atom/text-editor-marker-layer');
import ScopeDescriptor = require('~atom/scope-descriptor');

import CursorChangeEventHandler = require('~atom/cursor-change-event-handler');
import SelectionChangeEventHandler = require('~atom/selection-change-event-handler');
import GrammarEventHandler = require('first-mate/grammar-event-handler');
import ClipScreenPositionOption = require('~atom/clip-screen-position-option');

class TextEditor {
  onDidChangeTitle: (callback: () => void) => Disposable;
  onDidChangePath: (callback: () => void) => Disposable;
  onDidChange: (callback: () => void) => Disposable;
  onDidStopChanging: (callback: () => void) => Disposable;
  onDidChangeCursorPosition: CursorChangeEventHandler;
  onDidChangeSelectionRange: SelectionChangeEventHandler;
  onDidSave(callback: (event: { path: string }) => void): Disposable;
  onDidDestroy: (callback: () => void) => Disposable;
  getBuffer(): TextBuffer;
  observeGutters(callback: (gutter: Gutter) => void): Disposable;
  onDidAddGutter(callback: (gutter: Gutter) => void): Disposable;
  onDidRemoveGutter(callback: (name: string) => void): Disposable;

  // Extended Methods
  onDidChangeSoftWrapped: (callback: () => void) => Disposable;
  onDidChangeEncoding: (callback: () => void) => Disposable;
  observeGrammar: GrammarEventHandler;
  onDidChangeGrammar: GrammarEventHandler;
  onDidChangeModified: (callback: () => void) => Disposable;
  onDidConflict: (callback: () => void) => Disposable;
  onWillInsertText(callback: (event: { text: string, cancel(): void }) => void): Disposable;
  onDidInsertText(callback: (event: { text: string }) => void): Disposable;
  observeCursors(callback: (cursor: Cursor) => void): Disposable;
  onDidAddCursor(callback: (cursor: Cursor) => void): Disposable;
  onDidRemoveCursor(callback: (cursor: Cursor) => void): Disposable;
  observeSelections(callback: (selection: Selection) => void): Disposable;
  onDidAddSelection(callback: (selection: Selection) => void): Disposable;
  onDidRemoveSelection(callback: (selection: Selection) => void): Disposable;
  observeDecorations(callback: (decoration: Decoration) => void): Disposable;
  onDidAddDecoration(callback: (decoration: Decoration) => void): Disposable;
  onDidRemoveDecoration(callback: (decoration: Decoration) => void): Disposable;
  onDidChangePlaceholderText(callback: (placeholderText: string) => void): Disposable;

  // File Details
  getTitle(): string;
  getLongTitle(): string;
  getPath(): string;
  isModified(): boolean;
  isEmpty(): boolean

  // Extended Methods
  getEncoding(): string;
  setEncoding(encoding): void;

  // File Operations
  save(): void;
  saveAs(filePath: string): void;

  // Reading Text
  getText(): string;
  getTextInBufferRange(range: Range): string;
  getLineCount(): number;
  getScreenLineCount(): number;
  getLastBufferRow(): number;
  getLastScreenRow(): number;
  lineTextForBufferRow(bufferRow: number): string;
  lineTextForScreenRow(screenRow: number): string;
  getCurrentParagraphBufferRange(): Range;

  // Mutating Text
  setText(text: string): void
  setTextInBufferRange(range: Range, text: string, options?: {
    normalizeLineEndings?: boolean,
    undo?: 'skip'
  }): Range;
  insertText(text: string, options?: {
    select: boolean;
    autoIndent: boolean;
    autoIndentNewLine: boolean;
    autoDecreaseIndent: boolean;
    normalizeLineEndings?: boolean;
    undo: 'skip'
  }): Range | boolean;
  insertNewline(): void;
  delete(): void;
  backspace(): void;

  // Extended Methods
  mutateSelectedText(fn: (selection: Selection, index: number) => void): void;
  transpose(): void;
  upperCase(): void;
  lowerCase(): void;
  toggleLineCommentsInSelection(): void;
  insertNewlineBelow(): void;
  insertNewlineAbove(): void;
  deleteToBeginningOfWord(): void;
  deleteToPreviousWordBoundary(): void;
  deleteToNextWordBoundary(): void;
  deleteToBeginningOfSubword(): void;
  deleteToEndOfSubword(): void;
  deleteToBeginningOfLine(): void;
  deleteToEndOfLine(): void;
  deleteToEndOfWord(): void;
  deleteLine(): void;

  // History
  undo(): void;
  redo(): void;

  // Extended Methods
  transact(fn: Function): void;
  transact(groupingInterval: number, fn: Function): void;
  abortTransaction(): void;
  createCheckpoint(): any;
  revertToCheckpoint(): boolean;
  groupChangesSinceCheckpoint(): boolean;

  // TextEditor Coordinates
  screenPositionForBufferPosition(bufferPosition: Point | number[], options?: ClipScreenPositionOption): Point;
  bufferPositionForScreenPosition(bufferPosition: Point | number[], options?: ClipScreenPositionOption): Point;
  screenRangeForBufferRange(bufferRange: Range): Range;
  bufferRangeForScreenRange(screenRange: Range): Range;

  // Extended Methods
  clipBufferPosition(bufferPosition: Point): Point;
  clipBufferRange(range: Range): Range;
  clipScreenPosition(screenPosition: Point, options?: ClipScreenPositionOption): Point;
  clipScreenRange(range: Range, options?: ClipScreenPositionOption): Range;

  // Decorations
  decorateMarker(marker: TextEditorMarker, decorationParams: {
    type: 'line' | 'line-number' | 'highlight' | 'overlay' | 'gutter' | 'block',
    class: string,
    item?: HTMLElement | Object,
    onlyHead?: boolean,
    onlyEmpty?: boolean,
    onlyNonEmpty?: boolean,
    position?: 'head' | 'tail' | 'before' | 'after'
  }): Decoration;
  decorateMarkerLayer(markerLayer: TextEditorMarkerLayer | MarkerLayer, decorationParams: {
    type: 'line' | 'line-number' | 'highlight' | 'block',
    class: string,
    item?: HTMLElement | Object,
    onlyHead?: boolean,
    onlyEmpty?: boolean,
    onlyNonEmpty?: boolean,
    position?: 'head' | 'tail' | 'before' | 'after'
  }): Decoration;

  // Extended Methods
  getDecorations(propertyFilter?: Object): Decoration[];
  getLineDecorations(propertyFilter?: Object): Decoration[];
  getLineNumberDecorations(propertyFilter?: Object): Decoration[];
  getHighlightDecorations(propertyFilter?: Object): Decoration[];
  getOverlayDecorations(propertyFilter?: Object): Decoration[];

  // Markers
  markBufferRange(range: Range | Point[], properties: {
    maintainHistory?: boolean,
    reversed?: boolean,
    persistent?: boolean,
    invalidate?: 'never' | 'surround' | 'overlap' | 'inside' | 'touch'
  }): TextEditorMarker;
  markScreenRange(range: Range, properties: {
    maintainHistory?: boolean,
    reversed?: boolean,
    persistent?: boolean,
    invalidate?: 'never' | 'surround' | 'overlap' | 'inside' | 'touch'
  }): TextEditorMarker;
  markBufferPosition(position: Point | number[], options?: {
    reversed?: boolean,
    persistent?: boolean,
    invalidate?: 'never' | 'surround' | 'overlap' | 'inside' | 'touch'
  }): TextEditorMarker;
  markScreenPosition(position: Point | number[], options?: {
    reversed?: boolean,
    persistent?: boolean,
    invalidate?: 'never' | 'surround' | 'overlap' | 'inside' | 'touch'
  }): TextEditorMarker;
  findMarkers(properties: {
    startBufferRow: number,
    endBufferRow: number,
    containsBufferRange: Range | Point[],
    containsBufferPosition: Point | number[]
  }): TextEditorMarker[];
  getMarkerLayer(id: any): TextEditorMarkerLayer;
  getDefaultMarkerLayer(): TextEditorMarkerLayer;

  // Extended Methods
  getMarker(id: number): TextEditorMarker;
  getMarkers(): TextEditorMarker[];
  getMarkerCount(): number;
  addMarkerLayer(options: { maintainHistory?: boolean }): TextEditorMarkerLayer;

  // Cursors
  getCursorBufferPosition(): Point;
  getCursorBufferPositions(): Point[];
  setCursorBufferPosition(position: Point | number[], options?: { autoscroll?: boolean }): void
  getCursorAtScreenPosition(position: Point | number[]): Cursor;
  getCursorScreenPosition(): Point;
  getCursorScreenPositions(): Point[];
  setCursorScreenPosition(position: Point | number[], options?: { autoscroll?: boolean }): void;
  addCursorAtBufferPosition(bufferPosition: Point): Cursor;
  addCursorAtScreenPosition(screenPosition: Point): Cursor;
  hasMultipleCursors(): boolean;
  moveUp(lineCount?: number): void;
  moveDown(lineCount?: number): void;
  moveLeft(columnCount?: number): void;
  moveRight(columnCount?: number): void;
  moveToBeginningOfLine(): void;
  moveToBeginningOfScreenLine(): void;
  moveToFirstCharacterOfLine(): void;
  moveToEndOfLine(): void;
  moveToEndOfScreenLine(): void;
  moveToBeginningOfWord(): void;
  moveToEndOfWord(): void;

  // Extended Methods
  moveToTop(): void;
  moveToBottom(): void;
  moveToBeginningOfNextWord(): void;
  moveToPreviousWordBoundary(): void;
  moveToNextWordBoundary(): void;
  moveToPreviousSubwordBoundary(): void;
  moveToNextSubwordBoundary(): void;
  moveToBeginningOfNextParagraph(): void;
  moveToBeginningOfPreviousParagraph(): void;
  getLastCursor(): Cursor;
  getWordUnderCursor(options?: { wordRegex?: RegExp, includeNonWordCharacters: boolean, allowPrevious: boolean }): string;
  getCursors(): Cursor[];
  getCursorsOrderedByBufferPosition(): Cursor[];

  // Selections
  getSelectedText(): string;
  getSelectedBufferRange(): Range;
  getSelectedBufferRanges(): Range[];
  setSelectedBufferRange(bufferRange: Range | Point[], options?: {
    reversed: boolean,
    preserveFolds: boolean
  }): void;
  setSelectedBufferRanges(bufferRanges: Range[] | Point[][], options?: {
    reversed: boolean,
    preserveFolds: boolean
  }): void;
  getSelectedScreenRange(): Range;
  getSelectedScreenRanges(): Range[];
  setSelectedScreenRange(screenRange: Range | Point[], options?: { reversed: boolean }): void;
  setSelectedScreenRanges(screenRangee: Range[] | Point[][], options?: { reversed: boolean }): void;
  addSelectionForBufferRange(bufferRange, options?: { reversed: boolean }): Selection;
  addSelectionForScreenRange(screenRange, options?: { reversed: boolean }): Selection;
  selectToBufferPosition(position: Point): void;
  selectToScreenPosition(position: Point): void;
  selectUp(rowCount: number): void;
  selectDown(rowCount: number): void;
  selectLeft(columnCount: number): void;
  selectRight(columnCount: number): void;
  selectToTop(): void;
  selectToBottom(): void;
  selectAll(): void;
  selectToBeginningOfLine(): void;
  selectToFirstCharacterOfLine(): void;
  selectToEndOfLine(): void;
  selectToBeginningOfWord(): void;
  selectToEndOfWord(): void;
  selectLinesContainingCursors(): void;
  selectWordsContainingCursors(): void;

  // Extended Methods
  selectToPreviousSubwordBoundary(): void;
  selectToNextSubwordBoundary(): void;
  selectToPreviousWordBoundary(): void;
  selectToNextWordBoundary(): void;
  selectToBeginningOfNextWord(): void;
  selectToBeginningOfNextParagraph(): void;
  selectToBeginningOfPreviousParagraph(): void;
  selectMarker(marker: TextEditorMarker): void;
  getLastSelection(): Selection;
  getSelections(): Selection[];
  getSelectionsOrderedByBufferPosition(): Selection[];
  selectionIntersectsBufferRange(bufferRange: Range | Point[]): boolean;

  // Searching and Replacing
  scan: ScanFunction;
  scanInBufferRange: ScanInRangeFunction;
  backwardsScanInBufferRange: ScanInRangeFunction;

  // Tab Behavior
  getSoftTabs(): boolean;
  setSoftTabs(softTabs: boolean): void;
  toggleSoftTabs(): void;
  getTabLength(): number;
  setTabLength(tabLength: number): void;

  // Extended Methods
  usesSoftTabs(): boolean;
  getTabText(): string;

  // Soft Wrap Behavior
  isSoftWrapped(): boolean;
  setSoftWrapped(softWrapped: boolean): void;
  toggleSoftWrapped(): void;
  getSoftWrapColumn(): number;

  // Indentation
  indentationForBufferRow(bufferRow: number): number;
  setIndentationForBufferRow(bufferRow: number, newLevel: number, options?: { preserveLeadingWhitespace: boolean }): void;

  // Extended Methods
  indentSelectedRows(): void;
  outdentSelectedRows(): void;
  indentLevelForLine(line: string): number;
  autoIndentSelectedRows(): void;

  // Grammars
  getGrammar(): Grammar;
  setGrammar(grammar: Grammar): void;

  // Managing Syntax Scopes
  getRootScopeDescriptor(): ScopeDescriptor;
  scopeDescriptorForBufferPosition(bufferPosition: Point | number[]): ScopeDescriptor;

  // Extended Methods
  bufferRangeForScopeAtCursor(scopeSelector: string): Range;
  isBufferRowCommented(): boolean;

  // Clipboard Operations
  copySelectedText(): void;
  cutSelectedText(): void;
  pasteText(options?: {
    select: boolean;
    autoIndent: boolean;
    autoIndentNewLine: boolean;
    autoDecreaseIndent: boolean;
    normalizeLineEndings?: boolean;
    undo: 'skip'
  }): void;
  cutToEndOfLine(): void;
  cutToEndOfBufferLine(): void;

  // Folds
  foldCurrentRow(): void;
  unfoldCurrentRow(): void;
  foldBufferRow(bufferRow: number): void;
  unfoldBufferRow(bufferRow: number): void;

  //  Extended Methods
  foldSelectedLines(): void;
  foldAll(): void;
  unfoldAll(): void;
  foldAllAtIndentLevel(level: number): void;
  isFoldableAtBufferRow(bufferRow: number): boolean;
  isFoldableAtScreenRow(bufferRow: number): boolean;
  toggleFoldAtBufferRow(): void;
  isFoldedAtCursorRow(): boolean;
  isFoldedAtBufferRow(bufferRow: number): boolean;
  isFoldedAtScreenRow(screenRow: number): boolean;

  // Gutters
  addGutter(options: { name: string, priority?: number, visible?: boolean }): Gutter;
  getGutters(): Gutter[];
  gutterWithName(name: string): Gutter;

  // Scrolling the TextEditor
  scrollToCursorPosition(options?: { center?: boolean }): void;
  scrollToBufferPosition(bufferPosition: Point | number[] | { row: number, column: number }, options?: { center?: boolean }): void;
  scrollToScreenPosition(screenPosition: Point | number[] | { row: number, column: number }, options?: { center?: boolean }): void;

  // TextEditor Rendering
  getPlaceholderText(): string
  setPlaceholderText(placeholderText: string): void;
}


export = TextEditor;
}
declare module 'atom/text-editor' {
import alias = require('~atom/text-editor');
export = alias;
}

// Generated by typings
// Source: atom.d.ts
declare module '~atom/atom' {
import BufferedProcess = require('~atom/buffer-process');
import BufferedNodeProcess = require('~atom/buffer-node-process');
import GitRepository = require('~atom/git-repository');
import Notification = require('~atom/notification');
import TextBuffer = require('text-buffer/text-buffer');
import Point = require('text-buffer/point');
import Range = require('text-buffer/range');
import File = require('node-pathwatcher/file');
import Directory = require('node-pathwatcher/directory');
import Emitter = require('event-kit/emitter');
import Disposable = require('event-kit/disposable');
import CompositeDisposable = require('event-kit/composite-disposable');

import KeymapManager = require('atom-keymap/keymap-manager');
import GrammarRegistry = require('first-mate/grammar-registry');

import CommandRegistry = require('~atom/command-registry');
import Config = require('~atom/config');
import Clipboard = require('~atom/clipboard');
import ContextMenuManager = require('~atom/context-menu-manager');
import MenuManager = require('~atom/menu-manager');
import TooltipManager = require('~atom/tooltip-manager');
import NotificationManager = require('~atom/notification-manager');
import Project = require('~atom/project');
import PackageManager = require('~atom/package-manager');
import ThemeManager = require('~atom/theme-manager');
import StyleManager = require('~atom/style-manager');
import DeserializerManager = require('~atom/deserializer-manager');
import ViewRegistry = require('~atom/view-registry');
import Workspace = require('~atom/workspace');
import Task = require('~atom/task');
import TextEditor = require('~atom/text-editor');

export var BufferedNodeProcess: BufferedNodeProcess;
export var BufferedProcess: BufferedProcess;
export var GitRepository: GitRepository;
export var Notification: Notification;
export var TextBuffer: TextBuffer;
export var Point: Point;
export var Range: Range;
export var File: File;
export var Directory: Directory;
export var Emitter: Emitter;
export var Disposable: Disposable;
export var CompositeDisposable: CompositeDisposable;
export var Task: Task;
export var TextEditor: TextEditor;


global {
  namespace atom {
    export var commands: CommandRegistry;
    export var config: Config;
    export var clipboard: Clipboard;
    export var contextMenu: ContextMenuManager;
    export var menu: MenuManager;
    export var keymaps: KeymapManager;
    export var tooltips: TooltipManager;
    export var notifications: NotificationManager;
    export var project: Project;
    export var grammars: GrammarRegistry;
    export var packages: PackageManager;
    export var themes: ThemeManager;
    export var styles: StyleManager;
    export var deserializers: DeserializerManager;
    export var views: ViewRegistry;
    export var workspace: Workspace;

    // Extended Methods
    export function onDidBeep(callback: () => void): Disposable;
    export function onWillThrowError(callback: (event: {
      originalError: Object;
      message: string;
      url: string;
      line: number;
      column: number;
      preventDefault(): void;
    }) => void): Disposable;
    export function onDidThrowError(callback: (event: {
      originalError: Object;
      message: string;
      url: string;
      line: number;
      column: number;
    }) => void): Disposable;

    // Atom Details
    export function inDevMode(): boolean;
    export function inSafeMode(): boolean;
    export function inSpecMode(): boolean;
    export function getVersion(): string;
    export function isReleasedVersion(): boolean;
    export function getWindowLoadTime(): number;
    export function getLoadSettings(): Object;

    // Managing The Atom Window
    export function open(params: {
      pathsToOpen: string[];
      newWindow: boolean;
      devMode: boolean;
      safeMode: boolean;
    }): void;
    export function close();
    export function getSize(): { width: number, height: number };
    export function setSize(width: number, height: number): void;
    export function getPosition(): { x: number, y: number };
    export function setPosition(x: number, y: number): void;

    // Extended Methods
    export function pickFolder(callback: (paths: string[]) => void): void;
    export function getCurrentWindow(): any;
    export function center(): void;
    export function focus(): void;
    export function show(): void;
    export function hide(): void;
    export function reload(): void;
    export function isMaximized(): boolean;
    export function isFullScreen(): boolean;
    export function setFullScreen(): void;
    export function toggleFullScreen(): void;

    // Messaging The User
    export function beep(): void;
    export function confirm(options: {
      message: string;
      detailedMessage?: string;
      buttons?: string[] | Array<{
        [index: string]: Function;
      }>
    }): number;

    // Managing the Dev Tools
    // Extended Methods
    export function openDevTools(): PromiseLike<void>;
    export function toggleDevTools(): PromiseLike<void>;
    export function executeJavaScriptInDevTools(): void;
  }
}
}
declare module 'atom/atom' {
import alias = require('~atom/atom');
export = alias;
}
declare module 'atom' {
import alias = require('~atom/atom');
export = alias;
}
